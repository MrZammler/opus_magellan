

Introduction to the AmigaOS 3.5 (V44) Release Notes
***************************************************

›1m   PRELIMINARY›22m - last revised on 24 October 1999

   Copyright (C) 1999 Amiga, Inc. All rights reserved.

   This document describes the relevant changes and new features
introduced in AmigaOS 3.5 (release V44) since AmigaOS 3.1 (release V40).
Developers are invited to read this guide carefully and check their
products against the issues hereby discussed.

   This AmigaGuide® file is generated by Makeinfo-1.68. It is formatted
for viewing with AmigaGuide V40 or later. Please send comments,
suggestions and corrections for this text to Bernardo Innocenti
<bernie@cosmos.it>.

›1m›22m›1m›22m›1m›22m›1m›22m›1m›22m›1m›22mDetermining the Workbench version
*********************************

   An important point to mention is how to determine if a system is
running V44 instead of V40 or an earlier Workbench release. The
recommended approach is to open ›1mversion.library›22m, and check its version.
For example:

     struct Library *VersionBase;
     
     if (VersionBase = OpenLibrary("version.library", 0))
     {
         if (VersionBase->lib_Version >= 44)
         {
             /* user is running at least V44 Workbench */
         }
         else
         {
             /* user is running at most V37 Workbench */
         }
     }
     else
     {
         /* can't tell what the user is running, assume the minimum version
          * that your application supports
          */
     }

The above technique lets you determine which general version is in use
for the disk-based software.  Never assume this is a reflection of
every other library in the system.  For example, if you need features
of the ›1masl.library›22m that are only present since V44, you must explicitly
check the version of ›1masl.library›22m before using them. The same goes for
all other system libraries.

The Workbench
*************

   Workbench got rewritten for OS 3.5. The ›1mworkbench.library›22m API has
been extended with several new vectors to provide greater interaction
with Workbench-aware applications. There are now official (and clean)
ways for third party Workbench enhancers to gather information on the
current Workbench status, start programs in "Workench mode" and even
control some aspects of the Workbench user interface from other
applications.

   Of course the Workbench supports the new color mapped icons and other
features provided by the new ›1micon.library›22m. Icon Library.

Launching Workbench applications
================================

   The new OpenWorkbenchObject() can be used to execute a program as if
the user had double-clicked on its icon. This is expecially useful for
commodities that put up toolbars or menus to start other applications.

   Before V44, a similar functionality was made available by third-party
tools such as the ›1mwbstart.library›22m and the ›1mWBStart-Handler›22m.

   While third-party Workbench launchers are still supported in V44,
applications should be updated as soon as possible to use
OpenWorkbenchObject() when they detect a ›1mworkbench.library›22m whose
version is greater or equal to V44.

   Future versions of the Workbench may extend the WBStartup structure
to add new functionality. Then, the hack of sending faked WBStartup
messages to process's pr_MsgPort ›1mWILL STOP WORKING›22m.

   OpenWorkbenchObject() can also open drawers. This feature can be
useful in some Workbench enhancer commodities.

   Note that ›1mOpenWorkbenchObject()›22m fails if it is invoked while the
Workbench program is not running. This behaviour prevents usage of this
function by Workbench replacement applications. Workbench replacements
should launch applications autonomously. After all, the cleanest way to
duplicate Workbench functionality is providing a compatible replacement
of the workbench.library instead of patching most of its vectors.

Controlling the Workbench
=========================

   Another new function useful for commodities that extend the basic
Workbench functionality is ›1mWorkbenchControl()›22m. This function provides
several tags to query or modify global Workbench parameters or local
icon options. Consult the autodocs for a detailed description of the
available tags.

AppWindow icon drop zones
=========================

Adding drop zones
-----------------

   Once it is created, Workbench will allow the user to drop an icon
anywhere inside an ›1mAppWindow›22m, regardless of whether the icon was
dropped on an area designated for dropping icons on or not. With
›1mAddAppWindowDropZoneA()›22m you can tell Workbench which ›1mAppWindow›22m areas
are suitable for dropping icons on.

Drop zone ›1mAppMessage›22ms
---------------------

   Once an ›1mAppWindow›22m has a drop zone installed, Workbench will send a
new type of ›1mAppMessage›22m to your port if icons are dropped on a drop
zone. Instead of ›1mAMTYPE_APPWINDOW›22m type messages you will receive
›1mAMTYPE_APPWINDOWZONE›22m messages. In fact, you will no longer hear any
›1mAMTYPE_APPWINDOW›22m type messages since Workbench will allow users to drop
icons only on drop zones.  Be prepared to handle this.

   Adding a drop zone to an AppWindow does not guarantee that only
›1mAMTYPE_APPWINDOWZONE›22m type messages will arrive at your message port. In
fact, the user may be able to drop an icon on the window before the
first drop zone is installed. Be prepared to handle this.

Drop zones priority
-------------------

   Workbench checks drop zones in the order in which they were added to
the ›1mAppWindow›22m. Thus, if two zones overlap, the zone that was added
first will be reported as hit.

   An ›1mAppWindow›22m starts out with its entire area available for dropping
icons on. Thus, you may receive ›1mAppMessage›22ms for icons dropped upon your
›1mAppWindow›22m before you have added the first drop zone to it. Be prepared
to handle this.

Drop zone hooks
---------------

   Using the ›1mWBDZA_Hook›22m tag, you can set a hook that will be invoked
whenever the mouse enters or leaves your drop zone area. Your hook will
be called with the following parameters:


     result = hookFunc(hook,reserved,arm)
       D0               A0     A2     A1
     
     LONG hookFunc(struct Hook *hook, APTR reserved,
                   struct AppWindowDropZoneMsg *adzm);
     
     struct AppWindowDropZoneMsg
     {
         struct RastPort * adzm_RastPort;    /* RastPort to render into. */
         struct IBox       adzm_DropZoneBox; /* Limit your rendering to this area. */
         ULONG             adzm_ID;          /* \\ These come from straight */
         ULONG             adzm_UserData;    /* / from AddAppWindowDropZoneA(). */
         LONG              adzm_Action;      /* See below for a list of actions. */
     };
     
     #define ADZMACTION_Enter (0)
     #define ADZMACTION_Leave (1)

   The `reserved' parameter will be set to ›1mNULL›22m.  For future
enhancement, make sure that your hook function always returns ›1mNULL›22m.

   The drop zone message contents are as follows:

›1madzm_RastPort›22m
     A pointer to the ›1mRastPort›22m to render into. Typically, this is the
     ›1mRastPort›22m of the window the drop zone is attached to.

›1madzm_DropZoneBox›22m
     This member describes the position and size of the drop zone.  The
     zone is guaranteed to be a valid area, i.e. the Width and Height
     will both be greater than 0 and the Left/Top will be well within
     the bounds of the window containing the drop zone.

›1madzm_ID›22m
›1madzm_UserData›22m
     These two come straight from the values you passed as the `id' and
     `userData' parameters to ›1mAddAppWindowDropZoneA()›22m.

›1madzm_Action›22m
     Depending upon whether the mouse has just entered or left the drop
     zone area, this variable will be set to ›1mADZMACTION_Enter›22m or to
     ›1mADZMACTION_Leave›22m. Any other values for ›1madzm_Action›22m should be
     ignored.

   When the mouse enters the drop zone, do your drop zone area
highlighting. When the mouse leaves the drop zone, remove any
highlighting done in the previous ›1mADZMACTION_Enter›22m pass.

   Note that the mouse leaving your drop zone box does not imply that
no icons will be dropped on it. You may still receive a notification
lateron, telling you that your drop zone had icons dropped on it.  The
hook function is solely for highlighting and unhighlighting the drop
zone area.

   A final word of warning: when your hook code is called, you must
limit your rendering to simple drawing operations from ›1mgraphics.library›22m;
if you do anything complex that involves Intuition locking and unlocking
the display, such as refreshing gadgets or locking ›1mIntuitionBase›22m, you
will deadlock the operating system. You have been warned!

Removing drop zones
-------------------

   Use ›1mRemoveAppWindowDropZone()›22m to remove a drop zone previously added
with ›1mAddAppWindowDropZone()›22m. Due to the asynchronous nature of
Workbench/user interaction, you may receive ›1mAppIcon›22m drop zone messages
for zones that you have just removed. These messages may arrive in the
time between your code calling ›1mRemoveAppWindowDropZone()›22m and Workbench
responding to the drop zone removal request. Be prepared to handle
this. Once a drop zone is removed, it will generate no new ›1mAppMessage›22ms.

   Before the ›1mAppWindow›22m is removed, all its drop zones will be removed
first. There is no need for you to call ›1mRemoveAppWindowDropZone()›22m for
every single one.

New AppIcon functionality
=========================

Responding to menu commands
---------------------------

   As of Workbench V44, it is possible to invoke menu actions for
›1mAppIcon›22ms just like they were normal icons. You have to tell Workbench
which menu items your icon responds to using the tag item list you
provide to ›1mAddAppIconA()›22m. When one of the supported menu items is
invoked, you will receive an ›1mAppMessage›22m with the ›1mam_Class›22m entry set to
a value out of ›1mAMCLASSICON_Open›22m..›1mAMCLASSICON_EmptyTrash›22m, corresponding
to the menu item used.

   The following ›1mBOOL›22m tags are provided by ›1mAddAppIconA()›22m to control
which menu commands are supported by an ›1mAppIcon›22m:

›1mWBAPPICONA_SupportsOpen›22m

›1mWBAPPICONA_SupportsCopy›22m

›1mWBAPPICONA_SupportsRename›22m

›1mWBAPPICONA_SupportsInformation›22m

›1mWBAPPICONA_SupportsSnapshot›22m

›1mWBAPPICONA_SupportsUnSnapshot›22m

›1mWBAPPICONA_SupportsLeaveOut›22m

›1mWBAPPICONA_SupportsPutAway›22m

›1mWBAPPICONA_SupportsDelete›22m

›1mWBAPPICONA_SupportsFormatDisk›22m

›1mWBAPPICONA_SupportsEmptyTrash›22m
Custom AppIcon rendering hook
-----------------------------

   The new tag ›1mWBAPPICONA_RenderHook›22m takes a pointer to a ›1mstruct Hook›22m
that will be invoked when rendering your AppIcon. With this hook and
›1mWorkbenchControlA()›22m you can create dynamic or animated ›1mAppIcon›22ms. Your
hook will be called with the following parameters and has to return a
result value:


     result = hookFunc(hook, reserved, arm)
       D0               A0     A2      A1
     
     LONG hookFunc(struct Hook *hook, APTR reserved,
                   struct AppIconRenderMsg *arm);
     
     struct AppIconRenderMsg
     {
         struct RastPort *   arm_RastPort;
         struct DiskObject * arm_Icon;
         STRPTR              arm_Label;
         struct TagItem *    arm_Tags;
         WORD  arm_Left;
         WORD  arm_Top;
         WORD  arm_Width;
         WORD  arm_Height;
         ULONG  arm_State;
     };

The `reserved' parameter will be set to ›1mNULL›22m. The render message
contents are as follows:

›1marm_RastPort›22m
     A pointer to the RastPort to render into.

›1marm_Icon›22m
     A pointer to the Icon to be rendered.

›1marm_Label›22m
     A pointer to the label text to be printed below the icon.

›1marm_Tags›22m
     Further control tags which you should pass on to
     ›1micon.library/DrawIconStateA()›22m, should you call this routine.

›1marm_Left›22m
›1marm_Top›22m
     Rendering origin; note that these coordinates DO NOT take the
     embossing border sizes into account.

›1marm_Width›22m
›1marm_Height›22m
     Size of the Icon's image area; you should limit your drawing to
     this area.

›1marm_State›22m
     An icon drawing state, such as used by
     ›1micon.library/DrawIconStateA()›22m.

   Note that all the data in the render message is read-only.

   If your hook code returns ›1mTRUE›22m, the ›1mAppIcon›22m's regular image will be
drawn. If your code returns ›1mFALSE›22m, the regular image will not be drawn;
this allows you to do all the icon's on-screen rendering with the
exception of the icon image used when dragging the icon on the screen.

AppIcon positioning
-------------------

   The new ›1mWBAPPICONA_PropagatePosition›22m tag allows the AppIcon's
position to be propagated back to the original ›1mDiskObject›22m you passed to
›1mAddAppIconA()›22m. By default, Workbench will make a copy of that
›1mDiskObject›22m's icon imagery, allowing the application to free the it.
But if you specify ›1mWBAPPICONA_PropagatePosition,TRUE›22m, Workbench will
assume that you will not free the ›1mDiskObject›22m and that the ›1mAppIcon›22m's
current position should be stored in its ›1mdo_CurrentX/do_CurrentY›22m
members.

AppIcon selection
-----------------

   The new tag ›1mWBAPPICONA_NotifySelectState›22m causes the application to
be be notified whenever the AppIcon becomes selected or unselected.
You will hear only state transitions, i.e. changes from selected to
unselected state and the other way round. On a state transition you
will receive ›1mAppMessage›22ms with the ›1mAppMessage->am_Class›22m member set to
›1mAMCLASSICON_Selected›22m or ›1mAMCLASSICON_Unselected›22m, respectively.

Summary of new functions in workbench.library
=============================================

›1mBOOL OpenWorkbenchObjectA(STRPTR name,struct TagItem *tags)›22m
     Open a drawer or launch a program as if the user had
     double-clicked on its icon.

›1mBOOL CloseWorkbenchObjectA(STRPTR name,struct TagItem *tags)›22m
     Close a drawer as if the user had clicked on the window close
     gadget.

›1mWorkbenchControlA(name,tags)›22m
     Query or modify global Workbench parameters or local icon options.

›1mstruct AppWindowDropZone * AddAppWindowDropZoneA(struct AppWindow *aw, ULONG id, ULONG userData, struct TagItem * tags)›22m
     Designate an ›1mAppWindow›22m area as suitable for dropping icons on.

›1mBOOL RemoveAppWindowDropZone(struct AppWindow *, struct AppWindowDropZone *)›22m
     Attempt to remove a drop zone from an ›1mAppWindow›22m.

›1mBOOL ChangeWorkbenchSelectionA(STRPTR name,struct Hook *hook, struct TagItem *tags);›22m
     Change the selection states of icons displayed by Workbench.

›1mBOOL MakeWorkbenchObjectVisibleA(STRPTR name,struct TagItem *tags)›22m
     Change a Workbench window in such a way as to make a particular
     icon visible.

The Icon Library
****************

   The ›1micon.library›22m has been enhanced to support palette mapped icons.
The icon file format has been extended in a backwards compatible way to
support palette mapped images as well as old-style images. This means
that V44 icons can contain TWO image sets: the old-style planar images
(for normal and selected states) and the new style palette mapped
images.

The New Palette Mapped Icons
============================

   The ›1micon.library›22m has been enhanced to support palette mapped icons.
The icon file format has been extended in a backwards compatible way to
support palette mapped images as well as old-style images. This means
that V44 icons can contain TWO image sets: the old-style planar images
(for normal and selected states) and the new style palette mapped
images.

   New API calls are provided to retrieve the V44 image data.  The
›1mGetDiskObject()›22m and ›1mGetDiskObjectNew()›22m calls are now declared obsolete:
they are still supported only for backwards compatiblity, therefore
they don't provide a way to access the new palette mapped images(1).

   Applications which manipulate icons should be adapted to use the new
›1mGetIconTagList()›22m. This new function is a superset of ›1mGetDiskObject()›22m:
it still returns a pointer to a pointer to a ›1mstruct DiskObject›22m, but it
provides greater control by means of several taglist parameters.

   The defaults are to load and automatically remap the new style
images embedded into the icon. The ›1mICONGETA_Screen›22m tag specifies which
Screen the icon is to be displayed on.  See the ›1mGetIconTagList()›22m
AutoDoc for more information.

   The new ›1micon.library/IconControlA()›22m call allows the applications to
retrieve and change any of the extended icon attributes including the
palette and the imagery.

   ---------- Footnotes ----------

   (1) Actually, this isn't completely true: the ›1mstruct DiskObject›22m
really contains the new images in its private data. The only way to
retrieve it is by calling ›1mDupDiskObject()›22m and passing the tag
›1mICONDUPA_ActivateImageData›22m. This trick is used by the Workbench as a
workaround to display the new style image in AppIcons provided by
non-V44-aware applications.

Support for Workbench enhancers and replacements
================================================

   The new ›1micon.library/IconControlA()›22m call provides a way for
applications to change the default parameters used by the ›1micon.library›22m
when reading, remapping, drawing and saving icons.

   This new functionality obsoletes most of the Workbench patches that
have been around before OS 3.5. There are now documented (and clean)
ways to disable icon borders and to install a hook to choose default
icons for icon-less files.

   For icon editors and other applications that need to create fresh new
icons, the ›1mNewDiskObject()›22m function provides a way to create and
initialize a ›1mDiskObject›22m structure. The old official way to do this was
to to get a default icon with ›1mGetDiskObjectNew()›22m or even create the
structure manually. The latter method is now considered ›1mOBSOLETE›22m and
›1mVERY SYSTEM UNFRIENDLY›22m. The V44 ›1micon.library›22m contains compatibility
code to distinguish between real ›1mDiskObject›22ms and fake ›1mDiskObject›22ms
created by unfair applications. These hacks will stop working once the
compatibility code is dropped for future versions of the ›1micon.library›22m.

About NewIcons
==============

   This extended icon format introduced in OS 3.5 duplicates and
obsoletes the features previously provided by the third party NewIcons
patch. Unlike NewIcons, the V44 color mapped icons do not encode the
image data in the icon tooltypes, so the new icon format is both faster
and more compact.  The ›1mnewicon.library›22m V40 can still load V44 icons and
decode the NewIcon images encoded in the tooltypes, but it can't access
the new V44 palette mapped images.

   The V44 Workbench has compatibility code to decode NewIcons using
the ›1mnewicon.library›22m, therefore it is no longer necessary to start the
›1mC:NewIcon›22m program from the ›1mStartup-Sequence›22m (1). This feature is active
by default, but it can be switched off using the Workbench preferences
editor.

   Once the migration to the new color mapped icon format will be
complete, future versions of the Workbench will drop NewIcon
compatibility.  A future version of ›1mnewicon.library›22m could be enhanced
to read the V44 image data as well as the original NewIcons format to
support old applications that have not been updated to the new V44 API.
As of this writing, such version of the ›1mnewicon.library›22m is not yet
available.

   The choice of using a different scheme for palette mapped images
instead of conforming to the de-facto standard set by NewIcons was
necessary because the ›1mnewicon.library›22m API had a number of limitations
and inconsistencies which couldn't be worked around straightforwardly.
Programmers are therefore urged to adapt their applications to the new
›1micon.library›22m API as soon as possible.

   ---------- Footnotes ----------

   (1) In fact, it is strongly discouraged because it installs patches
on the ›1micon.library›22m with no support for the new extensions.

Drawing icons in applications
=============================

›1mDrawIconStateA()›22m
----------------

   The V44 ›1micon.library›22m provides functions to support applications
which need to display icons in their own GUI. These include icon
editors, ›1mWBInfo()›22m patches and full Workbench replacements. The pre-V44
method to draw an icon inside a window was to manipulate the images
embedded into the icon directly. As of V44, this technique is strongly
discouraged.

   The new ›1micon.library/DrawIconStateA()›22m function provides the same
functionality in a straightforward way. Shall the icon appearance be
changed with future extensions of the ›1micon.library›22m, your application
will pick them up automatically.

›1mLayoutIconA()›22m
-------------

   The ›1micon.library›22m supports drawing icons on any screen (not just on
the Workbench screen). For these reason, icon imagery can be loaded into
memory and then remapped at a later time by calling ›1mLayoutIconA()›22m.

›1m   LayoutIconA()›22m is called implicitly by ›1mGetIconTagList()›22m (1). The
icons are automatically remapped for display on the screen selected
using ›1mIconControlA()›22m.  This could be undesiderable when your
application wants to display the icon on another screen.

   Note that ›1mLayoutIconA()›22m allocates shared pens from the passed screen
using the ›1mgraphics.library/ObtainBestPen()›22m function.  These pens will
be released when the icon is disposed (with ›1mFreeDiskObject()›22m) or when
the icon is remapped again by ›1mLayoutIcon()›22m. It is ›1mVERY IMPORTANT›22m that
your custom or public screen is not closed until there are still icon
objects remapped for it. See the ›1mLayoutIconA()›22m AutoDoc for possible
workarounds.

   ---------- Footnotes ----------

   (1) To prevent this from happening, you must explicitly set the
›1mICONGETA_RemapIcon›22m tag to FALSE.

Summary of new functions in icon.library
========================================

›1mstruct DiskObject *DupDiskObjectA(struct DiskObject *icon, struct TagItem *tags)›22m
     Create a duplicate of a ›1mDiskObject›22m in memory. It can also be used
     to create an extended (`native') ›1mDiskObject›22m data structure from an
     existing, traditional format ›1mDiskObject›22m.

›1mULONG IconControlA(struct DiskObject *, struct TagItem *)›22m
     Modify and query icon and icon.library options.

›1mVOID DrawIconStateA(struct RastPort *rp, struct DiskObject *icon, STRPTR label, LONG leftEdge, LONG topEdge, ULONG state,struct TagItem *tags)›22m
     Draw an icon as if it were an image; if a label is provided, it
     will be printed below it.

›1mBOOL GetIconRectangleA(struct RastPort *rp, struct DiskObject *icon, STRPTR label, struct Rectangle *rectangle, struct TagItem *tags)›22m
     Calculate the size of the area icon rendering would affect.

›1mstruct DiskObject *NewDiskObject(LONG type)›22m
     create an ›3mempty›23m ›1mDiskObject›22m structure, which has no image data
     associated with it. Still, all the necessary structures are in
     place, you just have to fill them in.

›1mstruct DiskObject *GetIconTagList(STRPTR name, struct TagItem *tags)›22m
     Retrieve an icon that can belong to a file/drawer/volume or it can
     be a default icon.

›1mBOOL PutIconTagList(STRPTR name,struct DiskObject *icon, struct TagItem *tags)›22m
     Store an icon; which can belong to a file/drawer/volume or it can
     be a default icon.

›1mBOOL LayoutIconA(struct DiskObject *icon,struct Screen *screen, struct TagItem *tags)›22m
     prepare an icon for display, either on a specific screen or using
     a default colour palette. It is useful only for palette mapped
     icons.

›1mVOID ChangeToSelectedIconColor(struct ColorRegister *cr)›22m
     change the provided RGB colour value to make it suitable for use
     in an icon's select image.  This may involve darkening or toning
     the colour.

The ASL Library
***************

   The ›1masl.library›22m has been improved in V44 to address a number of
localization, efficiency and GUI layout issues as well as fixing bugs.
For developers, there are also some new API extensions.

New Functions
=============

›1mVOID ActivateAslRequest(APTR requester)›22m
     Activate a modal requester from a different task context.

›1mVOID AbortAslRequest(APTR requester)›22m
     Attempt to tell the modal ASL requester provided to shut down and
     perform as if the user had clicked on the requester's window close
     gadget.

New Tags
========

›1mASLFR_InitialShowVolumes (BOOL)›22m
     When opening the file requester, read the list of active volumes,
     do not read the contents of the specified drawer.

›1mASLFR_SetSortBy (ULONG)›22m
›1mASLFR_GetSortBy (ULONG *)›22m
     Criteria for sorting the file list. This must be one of:

        * ›1mASLFRSORTBY_Name›22m - sort by name (default)

        * ›1mASLFRSORTBY_Date›22m - sort by date

        * ›1mASLFRSORTBY_Size›22m - sort by size

     If ›1mASLFR_GetSortBy›22m is passed to AslRequest(), the file requester
     will store its current sort criteria in the ULONG pointed to by
     the tag before leaving.

›1mASLFR_SetSortDrawers (ULONG)›22m
›1mASLFR_GetSortDrawers (ULONG *)›22m
     Determines where drawers are placed in the sorted list; this must
     be one of:

        * ›1mASLFRSORTDRAWERS_First›22m - drawers appear before all other
          files (default)

        * ›1mASLFRSORTDRAWERS_Mix›22m - drawers are sorted along with the the
          other files

        * ›1mASLFRSORTDRAWERS_Last›22m - drawers appear after all other files

     If ›1mASLFR_GetSortDrawers›22m is passed to AslRequest(), the file
     requester will store its current sort drawer list placement in the
     ULONG pointed to by this tag.

›1mASLFR_SetSortOrder (ULONG)›22m
›1mASLFR_GetSortOrder (ULONG *)›22m
     Selects the order in which the list is sorted; this must be one of:

        * ›1mASLFRSORTORDER_Ascend›22m - smallest/oldest files first,
          largest/newest files last (default)

        * ›1mASLFRSORTORDER_Descend›22m - largest/newest files first,
          smallest/oldest files last

     If ›1mASLFR_GetSortOrder›22m is passed to AslRequest(), the file
     requester will store its current sort order in the ULONG pointed
     to by this tag.

›1mASLFR_PopToFront (BOOL)›22m
›1mASLFO_PopToFront (BOOL)›22m
›1mASLSM_PopToFront (BOOL)›22m
     When set to TRUE, this tells ASL to bring the screen to the front
     the requester has opened on. (Default is TRUE).

The Picture Datatype
********************

   The V40 ›1mpicture.datatype›22m distributed with OS 3.1 had several weak
points and missing features which made it inadequate when the first RTG
systems with true-color support became available.  For this reason,
nowadays the original V40/V42 version has been obsoleted by third party
replacements featuring true-color support and other useful extensions.

   OS 3.5 integrates a rewritten ›1mpicture.datatype›22m whose API tries to be
as compatible as possible to these unofficial versions.

   The V44 ›1mpicture.datatype›22m works transparently with both `CyberGraphX'
and `Picasso 96'. It also integrates color reduction algorithms to
convert high/true-color pictures to palette-mapped bitmaps. The API
allows the programmer to choose among several quantization and
dithering techniques to get better quality or faster conversion.

General concepts
================

* ›1mpalette-mapped›22m
     a picture, bitmap or screen is said to be palette-mapped when the
     color of its pixels must be determined by looking up a color
     palette containing the RGB triplets associated with an index
     value. The palette is also called CLUT (Color Look-Up Table).

* ›1mdirect-mapped›22m
     a picture, bitmap or screen whose pixels directly contain an RGB
     triplet. Direct-mapped pictures do not need a palette.

* ›1mnative bitmap›22m
     a bitmap in which the image data is represented by bitplanes in
     the native format of the Amiga chipset (OCS/ECS/AGA).

* ›1mRTG bitmap›22m
     a bitmap with a custom pixel format which may not be accessed
     directly. Drawing into the bitmap must be performed through the
     functions provided by the ›1mgraphics.library›22m or by the RTG system.

Backwards compatibility
=======================

   For backwards compatibility, the unofficial V43 ›1mpicture.datatype›22m
implementations which were distributed with `CyberGraphX' and `Picasso
96' behaved just like the V42 and eariler implementations by default.
The picture returned to the application was stored in a native planar
bitmap, up to 8 bitplanes deep.

   In order to let the datatype allocate custom bitmaps (chunky 8bpp or
hi/truecolor), the application should set the PDTA_DestMode attribute
to PMODE_V43.

   This has changed as of V44. PMODE_V43 is now active by default.
Applications should never expect to get a native bitmap from the
picture.datatype unless they explicitly ask for PMODE_V42.

   The following summary shows the different behaviour kept by all the
known implementations of the ›1mpicture.datatype›22m:

* ›1mpicture.datatype V40/V42 (OS 3.1)›22m
     PDTA_DestMode is ignored

* ›1mpicture.datatype V43 (CyberGraphX)›22m
     PDTA_DestMode defaults to PMODE_V42. The returned bitmap is always
     a planar one, with up to 8 bitplanes.

* ›1mpicture.datatype V43 (Picasso 96)›22m
     PDTA_DestMode defaults to ›1mPMODE_V42›22m. However, the returned bitmap
     is ›1mNOT›22m native.

* ›1mpicture.datatype V44 (OS 3.5)›22m
     PDTA_DestMode defaults to ›1mPMODE_V43›22m. It can be explicitly forced
     to ›1mPMODE_V42›22m.

   The V42 mode is retained in ›1mpicture.datatype›22m V44 for backwards
compatibility only. Use of the V42 mode in new applications is ›1mSTRONGLY
DISCOURAGED›22m. The V43 mode provides better performance for both the
internal operations carried out by the datatype and for most bitmap to
screen blitting operations.

New methods in unofficial V43 ›1mpicture.datatype›22m
==============================================

›1mPDTM_WRITEPIXELARRAY›22m
     Transfer pixel data to the picture object in the specified format

›1mPDTM_READPIXELARRAY›22m
     Transfer pixel data from the picture object in the specified format

New tags in unofficial V43 ›1mpicture.datatype›22m
===========================================

›1mPDTA_SourceMode›22m
     Set the sub datatype interface mode

›1mPDTA_DestMode›22m
     Set the app datatype interface mode

›1mPDTA_UseFriendBitMap›22m
     Allocates the resulting bitmap as a friend bitmap

›1mPDTA_MaskPlane›22m
     NULL or mask plane for use with BltMaskBitMapRastPort()

New tags in V44
===============

›1mPDTA_WhichPicture›22m
     Index number of the picture to load

›1mPDTA_GetNumPictures›22m
     Get the number of pictures stored in the file

›1mPDTA_MaxDitherPens›22m
     Maximum number of colours to use for dithering

›1mPDTA_DitherQuality›22m
     Quality of the dithering algorithm to be used during color
     quantization

›1mPDTA_AllocatedPens›22m
     Pointer to the allocated pen table

The Installer program
*********************

   The latest pre-V44 release of the ›1mInstaller›22m was V43.2, distributed on
the Amiga Technologies FTP site.

Checking the Installer version
==============================

   If your installation script uses new features not available in
earlier versions of the ›1mInstaller›22m, it is important to check the
variable @INSTALLER-VERSION before using these new features. This
variable will default to 0 with old versions of ›1mInstaller›22m like V1.24,
so it is safe and easy to check.  Please do not do an exact equality
check. Check for a minimum revision, just like with libraries.

Backtracing
===========

   Starting with V44 the ›1mInstaller›22m allows backtracing in your script.
If you use this mechanism the ›1mAbort Install›22m button is replaced with a
›1mBack›22m button in most cases. You should define a ›1m(back)›22m parameter for all
statements and functions with user interaction that presents the ›1mBack›22m
button. If you don't the ›1mBack›22m button is disabled which may frustrate
the user. The following new commands support backtracing:

›1m(trace)›22m
     The trace statement sets an backtrace position. A retrace will
     continue on that position in the script.

›1m(retrace)›22m
     The retrace initiates the backtrace mechanism. It skips the last
     backtrace position and searchs for the previous one.

›1m(back <code>)›22m
     If the user press the ›1mBack›22m button the code is executed.  Typically
     this code will contain a ›1m(retrace)›22m statement the last statement.

Please see the ›1mInstaller.guide›22m for a detailed description of these
commands.

Interaction with the Workbench
==============================

   The V44 ›1mInstaller›22m provides a way for installation scripts to
interact with the Workbench. The following commands are new in V44:

›1m(openwbobject <argument> ...)›22m
     Open a Workbench object which can be a disk, a drawer, a trashcan,
     a tool or a project.

›1m(showwbobject <argument>)›22m
     This statement scrolls the view of an workbench drawer until the
     named icon is visible. The drawer has to be opened before.

›1m(closewbobject <argument>)›22m
     This statement closes the named workbench object. Currently only
     disks, trashcans and drawers can be closed.

Multimedia support
==================

   The V44 ›1mInstaller›22m provides support for displaying text and pictures
and playing sounds during the installation. It is also possible to have
the ›1mInstaller›22m open on its own screen to provide a full screen backdrop
for the installation. The OS 3.5 installer script makes use of these
new features to provide an eye pleasing installation procedure as well
as showing the user license in a separate window. Before V44, some
later installation scripts from third party applications already made
use of external programs to obtain similar results. It is recommended
that you adapt your existing scripts to use the new mechanisms built
into the Installer for increased consistency between different products.

   The following multimedia commands are provided by the V44 ›1mInstaller›22m:

›1m(effect <position> <effect> <color 1> <color 2>)›22m
     Sets the graphical effect that is used for the background.

›1m(showmedia <medianame> <filename> <position> <size> <borderflag> ...)›22m
     showmedia opens a datatype and presents it to the user.

›1m(setmedia <media> <action> [parameter])›22m
     Using the setmedia statement some action can be performed on the
     datatype.

›1m(closemedia <media>)›22m
     Closes a media file and removes it from memory.

Please see the ›1mInstaller.guide›22m for a detailed description of these
commands.

Rebooting the System
====================

   One new command allows to reboot the system automatically once the
installation has finished. This command should be used with extreme
caution: forced reboots are extremely annoying to most users.

›1m(reboot)›22m
     This commands reboots the Amiga.

The SetPatch command
********************

   The ›1mSetPatch›22m program has been extended in V44 to perform some
additional functions required by OS 3.5.

   - Remove ROM based libraries from Exec's library list before they
     have been opened by applications, so that a disk-based replacement
     can be subsequently loaded by ramlib. SetPatch defaults to remove
     ›1micon.library›22m and ›1mworkbench.library›22m automatically. This can be
     overridden with the ›1mDISABLEROMMODULES›22m command line parameter.
     This feature obsoletes the ›1mRemLibrary›22m command which was used in
     earlier OS 3.5 beta releases.

   - Load resident modules from ›1mDevs:Amiga ROM Update›22m and add them to
     Exec's residents list(1). The updated versions will then be
     initialized by Exec at bootstrap time. ›1mSetPatch›22m uses this feature
     to replace the ROM versions of the ›1mscsi.device›22m and the
     ›1mFastFileSystem›22m with the updated V44 versions. ›1mSetPatch›22m determines
     which modules need to be replaced automatically, but this can also
     be overridden by the command line parameters.

   The V44 ›1mSetPatch›22m command is designed to work with any Kickstart since
V37, altrough it has been tested extensively only on V40. ›1mNOTE WELL:›22m
The replacement modules included in ›1mAmiga ROM Update›22m are to be used on
Kickstart V40 ›1mONLY›22m so they won't work with earlier Kickstart versions.

   The ›1mCheckSetPatch.c›22m code fragment included in the NDK may help some
software developers to internally turn off workarounds for OS bugs
conditionally.

   [TODO: describe command line template]

   ---------- Footnotes ----------

   (1) This feature obsoletes the ›1mLoadV43Module›22m command which was
distributed with earlier V43 ›1mscsi.device›22m and ›1mFastFileSystem›22m updates.

Shell commands
**************

   The following updated shell commands are included with OS 3.5:

   - ›1m›22m AddDataTypes

   - ›1m›22m ConClip

   - ›1m›22m CPU

   - ›1m›22m Group

   - ›1m›22m Info

   - ›1m›22m IPrefs

   - ›1m›22m Join

   - ›1m›22m List

   - ›1m›22m LoadWB

   - ›1m›22m Mount

   - ›1m›22m Owner

   - ›1m›22m Protect

   - ›1m›22m Status

   - ›1m›22m Type

   - ›1m›22m Version

   [TODO]

Library Function Index
**********************



 (back <code>)                            ... Installer
 (closemedia <media>)                     ... Installer
 (closewbobject <argument>)               ... Installer
 (effect <position> <effect> <color 1> <color 2>) ... Installer
 (openwbobject <argument> ...)            ... Installer
 (reboot)                                 ... Installer
 (retrace)                                ... Installer
 (setmedia <media> <action> [parameter])  ... Installer
 (showmedia <medianame> <filename> <position> <size> <borderflag> ...) ... Installer
 (showwbobject <argument>)                ... Installer
 (trace)                                  ... Installer
 BOOL ChangeWorkbenchSelectionA(STRPTR name,struct Hook *hook, struct TagItem *tags); ... Workbench Functions
 BOOL CloseWorkbenchObjectA(STRPTR name,struct TagItem *tags) ... Workbench Functions
 BOOL GetIconRectangleA(struct RastPort *rp, struct DiskObject *icon, STRPTR label, struct Rectangle *rectangle, struct TagItem *tags) ... Icon Functions
 BOOL LayoutIconA(struct DiskObject *icon,struct Screen *screen, struct TagItem *tags) ... Icon Functions
 BOOL MakeWorkbenchObjectVisibleA(STRPTR name,struct TagItem *tags) ... Workbench Functions
 BOOL OpenWorkbenchObjectA(STRPTR name,struct TagItem *tags) ... Workbench Functions
 BOOL PutIconTagList(STRPTR name,struct DiskObject *icon, struct TagItem *tags) ... Icon Functions
 BOOL RemoveAppWindowDropZone(struct AppWindow *, struct AppWindowDropZone *) ... Workbench Functions
 struct AppWindowDropZone * AddAppWindowDropZoneA(struct AppWindow *aw, ULONG id, ULONG userData, struct TagItem * tags) ... Workbench Functions
 struct DiskObject *DupDiskObjectA(struct DiskObject *icon, struct TagItem *tags) ... Icon Functions
 struct DiskObject *GetIconTagList(STRPTR name, struct TagItem *tags) ... Icon Functions
 struct DiskObject *NewDiskObject(LONG type) ... Icon Functions
 ULONG IconControlA(struct DiskObject *, struct TagItem *) ... Icon Functions
 VOID AbortAslRequest(APTR requester)     ... ASL Library
 VOID ActivateAslRequest(APTR requester)  ... ASL Library
 VOID ChangeToSelectedIconColor(struct ColorRegister *cr) ... Icon Functions
 VOID DrawIconStateA(struct RastPort *rp, struct DiskObject *icon, STRPTR label, LONG leftEdge, LONG topEdge, ULONG state,struct TagItem *tags) ... Icon Functions
 WorkbenchControlA(name,tags)             ... Workbench Functions

Tags, Structures and Parameters Index
*************************************



 @installer-version                       ... Installer
 ASLFO_PopToFront (BOOL)                  ... ASL Library
 ASLFR_GetSortBy (ULONG *)                ... ASL Library
 ASLFR_GetSortDrawers (ULONG *)           ... ASL Library
 ASLFR_GetSortOrder (ULONG *)             ... ASL Library
 ASLFR_InitialShowVolumes (BOOL)          ... ASL Library
 ASLFR_PopToFront (BOOL)                  ... ASL Library
 ASLFR_SetSortBy (ULONG)                  ... ASL Library
 ASLFR_SetSortDrawers (ULONG)             ... ASL Library
 ASLFR_SetSortOrder (ULONG)               ... ASL Library
 ASLSM_PopToFront (BOOL)                  ... ASL Library
 PDTA_AllocatedPens                       ... Picture Datatype
 PDTA_DestMode                            ... Picture Datatype
 PDTA_DitherQuality                       ... Picture Datatype
 PDTA_GetNumPictures                      ... Picture Datatype
 PDTA_MaskPlane                           ... Picture Datatype
 PDTA_MaxDitherPens                       ... Picture Datatype
 PDTA_SourceMode                          ... Picture Datatype
 PDTA_UseFriendBitMap                     ... Picture Datatype
 PDTA_WhichPicture                        ... Picture Datatype
 PDTM_READPIXELARRAY                      ... Picture Datatype
 PDTM_WRITEPIXELARRAY                     ... Picture Datatype
 WBAPPICONA_SupportsCopy                  ... AppIcons
 WBAPPICONA_SupportsDelete                ... AppIcons
 WBAPPICONA_SupportsEmptyTrash            ... AppIcons
 WBAPPICONA_SupportsFormatDisk            ... AppIcons
 WBAPPICONA_SupportsInformation           ... AppIcons
 WBAPPICONA_SupportsLeaveOut              ... AppIcons
 WBAPPICONA_SupportsOpen                  ... AppIcons
 WBAPPICONA_SupportsPutAway               ... AppIcons
 WBAPPICONA_SupportsRename                ... AppIcons
 WBAPPICONA_SupportsSnapshot              ... AppIcons
 WBAPPICONA_SupportsUnSnapshot            ... AppIcons

Concept Index
*************



 AddAppWindowDropZoneA()                  ... Drop Zones
 Amiga ROM Update                         ... SetPatch
 AMTYPE_APPWINDOWZONE                     ... Drop Zones
 AppIcon custom rendering hook            ... AppIcons
 AppIcon Menu commands                    ... AppIcons
 AppIcon new features                     ... AppIcons
 AppIcons                                 ... Workbench
 Application Support Library              ... ASL Library
 AppMessage                               ... Drop Zones
 AppWindow                                ... Drop Zones
 AppWindowDropZoneMsg                     ... Drop Zones
 asl.library                              ... ASL Library
 Backwards compatibility                  ... Workbench Version
 Commodities, enhancing the Workbench     ... Workbench Replacements
 CyberGraphX                              ... Picture Datatype
 Datatypes                                ... Picture Datatype
 DrawIconsStateA()                        ... Drawing Icons
 Drop Zones                               ... Drop Zones
 Drop zones                               ... Workbench
 DupDiskObject()                          ... Palette Mapped Icons
 FastFileSystem                           ... SetPatch
 File Requester                           ... ASL Library
 GetDiskObject()                          ... Palette Mapped Icons
 GetDiskObjectNew()                       ... Palette Mapped Icons
 GetIconTagList()                         ... Palette Mapped Icons
 High Color bitmaps                       ... Picture Datatype
 icon.library                             ... Icon Library
 icon.library new functions               ... Icon Functions
 IconControlA()                           ... Workbench Replacements
 ICONGETA_RemapIcon                       ... Drawing Icons
 Icons                                    ... Icon Library
 Icons, drawing                           ... Drawing Icons
 Installer                                ... Installer
 LayoutIconA()                            ... Drawing Icons
 LoadV43Module                            ... SetPatch
 newicon.library                          ... About NewIcons
 NewIcons                                 ... About NewIcons
 OpenWorkbenchObject()                    ... OpenWorkbenchObject()
 Picasso 96                               ... Picture Datatype
 picture.datatype                         ... Picture Datatype
 PutIconTagList()                         ... Palette Mapped Icons
 RemLibrary                               ... SetPatch
 Requesters                               ... ASL Library
 RTG Bitmaps                              ... Picture Datatype
 scsi.device                              ... SetPatch
 SetPatch                                 ... SetPatch
 Shell commands                           ... Shell Commands
 True Color bitmaps                       ... Picture Datatype
 Version                                  ... Workbench Version
 version.library                          ... Workbench Version
 WBStartup structure <1>                  ... OpenWorkbenchObject()
 WBStartup structure                      ... Workbench
 Workbench enhancers                      ... Workbench Replacements
 Workbench program                        ... Workbench
 Workbench replacements                   ... Workbench Replacements
 workbench.library                        ... Workbench
 workbench.library new functions          ... Workbench Functions
 WorkbenchControl()                       ... WorkbenchControl()

